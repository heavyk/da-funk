// Generated by LiveScript 1.3.1
var _, Path, parseFunctionBasic, regex_slash, regex_quote, regex_newline, regex_tab, regex_tabspace, regex_space, regex_newspace, res$, i$, i, _iindent, clean_str, interjection, stringify, da_funk_scopes, da_funk_callthrough, empty_scope, freedom, objection, merge, improves, extend, formula, embody, out$ = typeof exports != 'undefined' && exports || this;
_ = require('lodash');
Path = require('path');
parseFunctionBasic = function(fn){
  var fnTxt, i, ii, iii, j, jj, name, args, body;
  fnTxt = typeof fn === 'string'
    ? fn
    : fn.toString().trim();
  i = fnTxt.indexOf('(');
  ii = fnTxt.indexOf(')');
  iii = fnTxt.indexOf('function');
  j = fnTxt.indexOf('{');
  jj = fnTxt.lastIndexOf('}');
  name = fnTxt.substring(iii, i).trim();
  args = fnTxt.substring(++i, ii).replace(new RegExp(' ', 'g'), '');
  body = fnTxt.substring(++j, jj).trim();
  return {
    name: name,
    args: args,
    body: body,
    isGenerator: ~fnTxt.substring(iii, j).indexOf('*')
  };
};
regex_slash = new RegExp('\\\\', 'g');
regex_quote = new RegExp('"', 'g');
regex_newline = new RegExp('\n', 'g');
regex_tab = new RegExp('\t', 'g');
regex_tabspace = new RegExp('\t  ', 'g');
regex_space = new RegExp(' ', 'g');
res$ = [];
for (i$ = 0; i$ <= 10; ++i$) {
  i = i$;
  res$.push(new RegExp('\n' + repeatString$(' ', i), 'g'));
}
regex_newspace = res$;
regex_newline = regex_newspace[0];
res$ = [];
for (i$ = 0; i$ <= 4; ++i$) {
  i = i$;
  res$.push(repeatString$('\t', i));
}
_iindent = res$;
clean_str = function(str){
  "use strict";
  return (str + '').replace(regex_slash, '\\\\').replace(regex_quote, '\\"').replace(regex_newline, '\\n').replace(regex_tab, '\\t');
};
interjection = function(fn, obj, desired_order, indent){
  var iindent, out, _fn, i, ii, j, jj, _fn_name, _fn_args, _fn_body, iii, len, k, doi, kk, i$, len$, key, o, name, args, body, _fn_indent;
  desired_order == null && (desired_order = []);
  indent == null && (indent = 1);
  if (!(iindent = _iindent[indent])) {
    iindent = _iindent[indent] = repeatString$('\t', indent);
  }
  out = [];
  _fn = typeof fn === 'function'
    ? fn.toString()
    : typeof fn === 'string'
      ? fn
      : function(){}.toString();
  i = _fn.indexOf('(');
  ii = _fn.indexOf(')');
  j = _fn.indexOf('{');
  jj = _fn.lastIndexOf('}');
  _fn_name = _fn.substring('function'.length, i);
  _fn_args = _fn.substring(++i, ii).replace(regex_space, '');
  _fn_body = _fn.substring(++j, jj).trim();
  if (~(i = _fn.indexOf('\n'))) {
    ii = i + 1;
    while (_fn[ii] === ' ') {
      ii++;
    }
    if (!regex_newspace[iii = ii - i + 1 - 2]) {
      regex_newspace[iii] = new RegExp('\n' + repeatString$(' ', iii), 'g');
    }
    _fn_body = _fn_body.replace(regex_newspace[ii - i + 1 - 2], '\n\t');
    do {
      len = _fn_body.length;
      _fn_body = _fn_body.replace(regex_tabspace, '\t\t');
    } while (_fn_body.length !== len);
  }
  if (_fn_body.length) {
    _fn_body = '\n\t' + _fn_body + '\n';
  }
  k = Object.keys(obj).sort();
  if ((doi = desired_order.length - 1) >= 0) {
    do {
      if (~(i = k.indexOf(desired_order[doi]))) {
        kk = k.splice(i, 1);
        k.unshift(kk[0]);
      }
    } while (--doi >= 0);
  }
  if (k.length) {
    for (i$ = 0, len$ = k.length; i$ < len$; ++i$) {
      key = k[i$];
      if ((o = obj[key]) === null) {
        out.push(key + ' = null');
      } else {
        switch (typeof o) {
        case 'function':
          _fn = o.toString();
          i = _fn.indexOf('(');
          ii = _fn.indexOf(')');
          j = _fn.indexOf('{');
          jj = _fn.lastIndexOf('}');
          name = _fn.substring('function'.length, i);
          args = _fn.substring(++i, ii).replace(regex_space, '');
          body = _fn.substring(++j, jj).trim();
          _fn_indent = _iindent[indent + 1];
          if (~(i = _fn.indexOf('\n'))) {
            ii = i + 1;
            while (_fn[ii] === ' ') {
              ii++;
            }
            if (!regex_newspace[iii = ii - i + 1 - 2]) {
              regex_newspace[iii] = new RegExp('\n' + repeatString$(' ', iii), 'g');
            }
            body = body.replace(regex_newspace[ii - i + 1 - 2], '\n' + _fn_indent);
            do {
              len = body.length;
              body = body.replace(regex_tabspace, '\t\t');
            } while (body.length !== len);
          }
          if (body.length) {
            body = '\n' + _fn_indent + body + '\n';
          }
          out.push(key + " = function" + name + "(" + args + "){" + (body + iindent) + "}");
          break;
        case 'string':
          out.push(key + ' = "' + clean_str(o) + '"');
          break;
        case 'number':
        case 'boolean':
          out.push(key + ' = ' + o);
          break;
        case 'object':
          if (typeof o.length === 'number' || _.isArray(o)) {
            if (o.length) {
              out.push(key + (" = [\n" + iindent + "\t") + _.map(o, fn$).join(",\n\t" + iindent) + ("\n" + iindent + "]"));
            } else {
              out.push(key + ' = []');
            }
          } else if (o === null) {
            out.push(key + ' = null');
          } else {
            out.push(key + ' = ' + stringify(o, desired_order, indent + 1));
          }
        }
      }
    }
    return typeof fn === 'string'
      ? ("function" + _fn_name + "(" + _fn_args + ") {\n" + iindent + "var ") + out.join(",\n" + iindent) + (";\n" + _iindent[indent - 1] + _fn_body + "\n}")
      : (console.log("new Function", _fn_args, _fn_body), new Function(_fn_args, _fn_body));
  } else if (indent === 1) {
    return "{}\n";
  } else {
    return "{}";
  }
  function fn$(vv){
    if (typeof vv === 'object') {
      return stringify(vv, desired_order, indent + 1);
    } else {
      return JSON.stringify(vv);
    }
  }
};
stringify = function(obj, desired_order, indent){
  var out, iindent, k, doi, i, kk, i$, len$, key, o, _fn, ii, j, jj, args, body, iii, len;
  desired_order == null && (desired_order = []);
  indent == null && (indent = 1);
  out = [];
  if (!(iindent = _iindent[indent])) {
    iindent = _iindent[indent] = repeatString$('\t', indent);
  }
  k = Object.keys(obj).sort();
  if ((doi = desired_order.length - 1) >= 0) {
    do {
      if (~(i = k.indexOf(desired_order[doi]))) {
        kk = k.splice(i, 1);
        k.unshift(kk[0]);
      }
    } while (--doi >= 0);
  }
  if (k.length) {
    for (i$ = 0, len$ = k.length; i$ < len$; ++i$) {
      key = k[i$];
      if ((o = obj[key]) === null) {
        out.push('"' + key + '": null');
      } else {
        switch (typeof o) {
        case 'function':
          out.push('"' + key + '": 8');
          o = o.toString();
          key += '.js';
          if (typeof obj[key] === 'undefined') {
            _fn = o.toString();
            i = _fn.indexOf('(');
            ii = _fn.indexOf(')');
            j = _fn.indexOf('{');
            jj = _fn.lastIndexOf('}');
            args = _fn.substring(++i, ii).replace(regex_space, '');
            body = _fn.substring(++j, jj).trim();
            if (~(i = _fn.indexOf('\n'))) {
              ii = i + 1;
              while (_fn[ii] === ' ') {
                ii++;
              }
              if (!regex_newspace[iii = ii - i + 1 - 2]) {
                regex_newspace[iii] = new RegExp('\n' + repeatString$(' ', iii), 'g');
              }
              body = body.replace(regex_newspace[ii - i + 1 - 2], '\n\t');
              do {
                len = body.length;
                body = body.replace(regex_tabspace, '\t\t');
              } while (body.length !== len);
            }
            if (body.length) {
              body = '\\n\\t' + clean_str(body) + '\\n';
            }
            out.push('"' + key + '": "function(' + args + '){' + body + '}"');
          }
          break;
        case 'string':
          out.push('"' + key + '": "' + clean_str(o) + '"');
          break;
        case 'number':
        case 'boolean':
          out.push('"' + key + '": ' + o);
          break;
        case 'object':
          if (typeof o.length === 'number' || _.isArray(o)) {
            if (o.length) {
              out.push('"' + key + ("\": [\n" + iindent + "\t") + _.map(o, fn$).join(",\n\t" + iindent) + ("\n" + iindent + "]"));
            } else {
              out.push('"' + key + '": []');
            }
          } else if (o === null) {
            out.push('"' + key + '": null');
          } else {
            out.push('"' + key + '": ' + stringify(o, desired_order, indent + 1));
          }
        }
      }
    }
    return ("{\n" + iindent) + out.join(",\n" + iindent) + ("\n" + _iindent[indent - 1] + "}" + (indent === 1 ? '\n' : ''));
  } else if (indent === 1) {
    return "{}\n";
  } else {
    return "{}";
  }
  function fn$(vv){
    if (typeof vv === 'object') {
      return stringify(vv, desired_order, indent + 1);
    } else {
      return JSON.stringify(vv);
    }
  }
};
da_funk_scopes = [];
da_funk_callthrough = [];
empty_scope = {};
da_funk_callthrough.i = 0;
freedom = function(obj, scope, refs){
  var basename, basepath, f, callthrough, i$, ref$, keys, len$, k, v, _fn;
  if (typeof obj !== 'object') {
    return {};
  }
  refs = typeof refs !== 'object'
    ? {}
    : _.cloneDeep(refs);
  basename = refs.name || '';
  basepath = refs.path;
  if (typeof refs.__i === 'undefined') {
    refs.__i = 0;
  }
  if (typeof scope !== 'object' || !scope) {
    scope = {};
  }
  f = new Function("var scope = this;\nif((typeof window !== 'object' || this !== window) && (typeof global !== 'object' || this !== global)) {\n	for (var i in this) {\n		eval(i+' = this[i];');\n	}\n}\nreturn function(name, refs, obj) {\n	var _fn, _fn_txt;\n	var f = function() {\n		try {\n			if(typeof (_fn_txt = obj[name+'.js']) === 'string') {\n				//console.log(\"generating function...\", name);\n				var i = _fn_txt.indexOf('(');\n				var ii = _fn_txt.indexOf(')');\n				var j = _fn_txt.indexOf('{');\n				var jj = _fn_txt.lastIndexOf('}');\n				var args = _fn_txt.substring(++i, ii).replace(new RegExp(' ', 'g'), '');\n				var body = '\"use strict\"\\n\"' + refs.name + '\"\\n' + _fn_txt.substring(++j, jj).trim();\n				_fn = new Function(args, body);\n				delete obj[name+'.js'];\n			}\n			return _fn.apply(this, arguments);\n		} catch(e) {\n			console.log(e.stack)\n			var s = (e.stack+'').split('\\n')\n			if(_fn) {\n				var line, _fn_s = _fn.toString().split('\\n');\n				line = (/\\:([0-9]+)\\:([0-9]+)\\)$/.exec(s[1]));\n				line = line ? line[1] * 1 : 'unknown';\n				var sp = \"          \".substr(2, (_fn_s.length+'').length);\n				var block = []\n				_fn_s.map(function(s, i) {\n					i++;\n					if(line < (i+3) && line > (i-3)) block.push((i++)+\":\"+sp+s)\n				}).join('\\n')\n				console.error(s[0]+\"\\n(\"+refs.name+\" line: \"+line+\")\\n\"+block.join('\\n'))\n				//throw e;\n			} else {\n				console.error(\"function was not able to be found\", refs)\n				throw e;\n			}\n		}\n	}\n	return f\n}");
  callthrough = f.call(scope);
  da_funk_scopes.push(obj);
  for (i$ = 0, len$ = (ref$ = keys = Object.keys(obj)).length; i$ < len$; ++i$) {
    k = ref$[i$];
    v = obj[k];
    if (v === 8 && typeof (_fn = obj[k + '.js']) === 'string') {
      refs.path = basepath ? basepath + '.' + k : k;
      refs.name = basename + '.' + k;
      delete obj[k + '.js'];
      Object.defineProperty(obj, k + '.js', {
        enumerable: false,
        value: _fn
      });
      obj[k] = callthrough(k, refs, obj);
    } else if (v && typeof v === 'object' && v !== obj && refs.__i <= (refs.deep || 4) && v.__proto__ === {}.__proto__) {
      refs.path = basepath ? basepath + '.' + k : k;
      refs.name = basename + '.' + k;
      ++refs.__i;
      freedom(obj[k], scope, refs);
      --refs.__i;
    }
  }
  return obj;
};
objection = function(object, scope, refs){
  var str;
  if (typeof str === 'string') {
    try {
      str = JSON.parse;
    } catch (e$) {}
  }
  return freedom(typeof str === 'string' ? JSON.parse(str) : str, scope, refs);
};
merge = function(a, b){
  var keys, i$, len$, k, v, c;
  keys = _.union(Object.keys(a), Object.keys(b));
  for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
    k = keys[i$];
    if (b.hasOwnProperty(k)) {
      v = b[k];
      c = a[k];
      a[k] = _.isArray(c)
        ? _.isArray(v)
          ? _.union(v, c)
          : typeof v !== 'undefined' ? c.concat(v) : c
        : _.isObject(v) && _.isObject(c)
          ? merge(c, v)
          : typeof c === 'undefined' ? v : c;
    }
  }
  return a;
};
improves = function(a, b){
  var keys, i$, len$, k, _b, _a, _k;
  if (typeof b === 'object' || typeof b === 'function') {
    keys = Object.keys(b);
    for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
      k = keys[i$];
      _b = b[k];
      _a = a[k];
      console.log("k:", k);
      if (b.hasOwnProperty(k) && k[0] !== '_') {
        _k = k;
        a[k] = _a !== _b && typeof _b === 'object' && typeof _a === 'object'
          ? improves(improves({}, _a), _b)
          : _b || _a;
      }
    }
  }
  return a;
};
extend = function(a, b){
  var keys, i$, len$, k, _k, _a, is_and, _b, isArray, __fn;
  if (typeof b === 'object' || typeof b === 'function') {
    keys = Object.keys(b);
    for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
      k = keys[i$];
      if (b.hasOwnProperty(k) && k[0] !== '_') {
        _k = k;
        _a = a[k];
        is_and = false;
        if (k.indexOf('also|') === 0) {
          is_and = true;
          _b = b[_k];
          k = k.substr("also|".length);
          _a = a[k];
        } else {
          if (k === 'initialize') {
            is_and = true;
          }
          _b = b[k];
        }
        a[k] = is_and && (typeof _a === 'function' || (is_and && (typeof a[_k] === 'function' && (_a = a[_k])))) && typeof _b === 'function'
          ? (isArray = _.isArray(_a.___fnArray))
            ? (_a.___fnArray.push(_b), _a)
            : (__fn = fn$, __fn.___fnArray = [_a, _b], __fn)
          : _.isArray(_a)
            ? _.isArray(_b)
              ? _.union(_b, _a)
              : typeof _b !== 'undefined' ? _a.concat(_b) : _a
            : _a !== _b && typeof _b === 'object' && typeof _a === 'object'
              ? extend(extend({}, _a), _b)
              : _b || _a;
      }
    }
  }
  return a;
  function fn$(){
    var i$, ref$, len$, _fn, results$ = [];
    for (i$ = 0, len$ = (ref$ = __fn.___fnArray).length; i$ < len$; ++i$) {
      _fn = ref$[i$];
      results$.push(_fn.apply(this, arguments));
    }
    return results$;
  }
};
formula = function(a, b){};
embody = function(obj){
  var deps, i, a;
  deps = {};
  i = arguments.length;
  while (i-- > 1) {
    if (_.isObject(a = arguments[i])) {
      deps = extend(deps, a);
    }
  }
  return merge(obj, deps);
};
stringify.desired_order = function(path){
  switch (Path.basename(path)) {
  case 'component.json':
  case 'package.json':
    return ['name', 'version', 'description', 'homepage', 'author', 'contributors', 'maintainers', 'repo', 'dependencies'];
  default:
    return [];
  }
};
out$.parseFunctionBasic = parseFunctionBasic;
out$.stringify = stringify;
out$.freedom = freedom;
out$.interjection = interjection;
out$.objection = objection;
out$.merge = merge;
out$.extend = extend;
out$.improves = improves;
out$.embody = embody;
function repeatString$(str, n){
  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
  return r;
}